@page "/counter"
@inject ILogger<Counter> Logger
@inject PersistentComponentState ApplicationState
@rendermode InteractiveServer
@implements IDisposable

<PageTitle>Counter</PageTitle>

<h1>Counter with State Persistence (.NET 10)</h1>

<div class="alert alert-info" role="alert">
    <strong>Blue-Green Deployment Demo:</strong> This counter's state persists across server restarts using .NET 10's built-in state persistence APIs!
    <br /><small>Using: PersistentComponentState service</small>
</div>

<p role="status">Current count: <strong>@currentCount</strong></p>

<div class="btn-group" role="group">
    <button class="btn btn-primary" @onclick="IncrementCount">Increment</button>
    <button class="btn btn-secondary" @onclick="DecrementCount">Decrement</button>
    <button class="btn btn-warning" @onclick="ResetCount">Reset</button>
</div>

<div class="mt-3">
    <button class="btn btn-info" @onclick="ShowStateInfo">ℹ️ Show State Info</button>
</div>

@if (!string.IsNullOrEmpty(statusMessage))
{
    <div class="alert alert-success mt-3" role="alert">
        @statusMessage
    </div>
}

@code {
    private int currentCount = 0;
    private string statusMessage = string.Empty;
    private PersistingComponentStateSubscription _persistingSubscription;

    protected override void OnInitialized()
    {
        // Try to restore state from previous session
        if (ApplicationState.TryTakeFromJson<int>("currentCount", out var restoredCount))
        {
            currentCount = restoredCount;
            Logger.LogInformation("State restored! Count: {Count}", currentCount);
            
            statusMessage = $"State restored! Count: {currentCount}";
            Task.Run(async () =>
            {
                await Task.Delay(3000);
                statusMessage = string.Empty;
                await InvokeAsync(StateHasChanged);
            });
        }
        
        // Register callback to persist state when circuit is evicted
        _persistingSubscription = ApplicationState.RegisterOnPersisting(PersistState);
        
        Logger.LogInformation("Counter component initialized. Current count: {Count}", currentCount);
    }

    private Task PersistState()
    {
        // Persist the current count when the circuit is about to be evicted
        ApplicationState.PersistAsJson("currentCount", currentCount);
        Logger.LogInformation("Persisting state: Count = {Count}", currentCount);
        return Task.CompletedTask;
    }

    private void IncrementCount()
    {
        currentCount++;
        Logger.LogInformation("Count incremented to {Count}", currentCount);
    }

    private void DecrementCount()
    {
        currentCount--;
        Logger.LogInformation("Count decremented to {Count}", currentCount);
    }

    private void ResetCount()
    {
        currentCount = 0;
        Logger.LogInformation("Count reset to 0");
    }

    private async Task ShowStateInfo()
    {
        statusMessage = $"Current count: {currentCount} | Using .NET 10 PersistentComponentState API";
        StateHasChanged();
        
        await Task.Delay(3000);
        statusMessage = string.Empty;
        StateHasChanged();
    }

    public void Dispose()
    {
        _persistingSubscription.Dispose();
    }
}

